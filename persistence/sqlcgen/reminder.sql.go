// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reminder.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createReminder = `-- name: CreateReminder :one
INSERT INTO reminders (
    recurring_transaction_id, reminder_date
) VALUES (
    $1, $2
) RETURNING id, created_at, updated_at, deleted_at, recurring_transaction_id, reminder_date, is_read, read_at
`

type CreateReminderParams struct {
	RecurringTransactionID string
	ReminderDate           pgtype.Timestamptz
}

func (q *Queries) CreateReminder(ctx context.Context, arg CreateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, createReminder, arg.RecurringTransactionID, arg.ReminderDate)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.RecurringTransactionID,
		&i.ReminderDate,
		&i.IsRead,
		&i.ReadAt,
	)
	return i, err
}

const deleteReminder = `-- name: DeleteReminder :exec
UPDATE reminders
SET
    deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteReminder(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteReminder, id)
	return err
}

const getActiveRemindersByUserID = `-- name: GetActiveRemindersByUserID :many
SELECT r.id, r.created_at, r.updated_at, r.deleted_at, r.recurring_transaction_id, r.reminder_date, r.is_read, r.read_at
FROM reminders r
JOIN recurring_transactions rt ON r.recurring_transaction_id = rt.id
WHERE rt.user_id = $1 AND r.is_read = FALSE AND r.reminder_date <= $2 AND r.deleted_at IS NULL AND rt.deleted_at IS NULL
ORDER BY r.reminder_date ASC
`

type GetActiveRemindersByUserIDParams struct {
	UserID       string
	ReminderDate pgtype.Timestamptz
}

func (q *Queries) GetActiveRemindersByUserID(ctx context.Context, arg GetActiveRemindersByUserIDParams) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getActiveRemindersByUserID, arg.UserID, arg.ReminderDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.RecurringTransactionID,
			&i.ReminderDate,
			&i.IsRead,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReminderByID = `-- name: GetReminderByID :one
SELECT id, created_at, updated_at, deleted_at, recurring_transaction_id, reminder_date, is_read, read_at FROM reminders
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetReminderByID(ctx context.Context, id string) (Reminder, error) {
	row := q.db.QueryRow(ctx, getReminderByID, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.RecurringTransactionID,
		&i.ReminderDate,
		&i.IsRead,
		&i.ReadAt,
	)
	return i, err
}

const getRemindersByRecurringTransactionID = `-- name: GetRemindersByRecurringTransactionID :many
SELECT id, created_at, updated_at, deleted_at, recurring_transaction_id, reminder_date, is_read, read_at FROM reminders
WHERE recurring_transaction_id = $1 AND deleted_at IS NULL
ORDER BY reminder_date ASC
`

func (q *Queries) GetRemindersByRecurringTransactionID(ctx context.Context, recurringTransactionID string) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersByRecurringTransactionID, recurringTransactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.RecurringTransactionID,
			&i.ReminderDate,
			&i.IsRead,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingReminders = `-- name: GetUpcomingReminders :many
SELECT r.id, r.created_at, r.updated_at, r.deleted_at, r.recurring_transaction_id, r.reminder_date, r.is_read, r.read_at, rt.name AS transaction_name, rt.amount, rt.type
FROM reminders r
JOIN recurring_transactions rt ON r.recurring_transaction_id = rt.id
WHERE rt.user_id = $1
  AND r.is_read = FALSE
  AND r.reminder_date BETWEEN $2 AND $3
  AND r.deleted_at IS NULL
  AND rt.deleted_at IS NULL
ORDER BY r.reminder_date ASC
`

type GetUpcomingRemindersParams struct {
	UserID         string
	ReminderDate   pgtype.Timestamptz
	ReminderDate_2 pgtype.Timestamptz
}

type GetUpcomingRemindersRow struct {
	ID                     string
	CreatedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
	DeletedAt              pgtype.Timestamptz
	RecurringTransactionID string
	ReminderDate           pgtype.Timestamptz
	IsRead                 bool
	ReadAt                 pgtype.Timestamptz
	TransactionName        string
	Amount                 decimal.Decimal
	Type                   string
}

func (q *Queries) GetUpcomingReminders(ctx context.Context, arg GetUpcomingRemindersParams) ([]GetUpcomingRemindersRow, error) {
	rows, err := q.db.Query(ctx, getUpcomingReminders, arg.UserID, arg.ReminderDate, arg.ReminderDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUpcomingRemindersRow{}
	for rows.Next() {
		var i GetUpcomingRemindersRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.RecurringTransactionID,
			&i.ReminderDate,
			&i.IsRead,
			&i.ReadAt,
			&i.TransactionName,
			&i.Amount,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markReminderAsRead = `-- name: MarkReminderAsRead :one
UPDATE reminders
SET
    is_read = TRUE,
    read_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, recurring_transaction_id, reminder_date, is_read, read_at
`

func (q *Queries) MarkReminderAsRead(ctx context.Context, id string) (Reminder, error) {
	row := q.db.QueryRow(ctx, markReminderAsRead, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.RecurringTransactionID,
		&i.ReminderDate,
		&i.IsRead,
		&i.ReadAt,
	)
	return i, err
}
