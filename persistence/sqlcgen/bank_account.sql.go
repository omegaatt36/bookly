// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bank_account.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBankAccount = `-- name: CreateBankAccount :one
INSERT INTO bank_accounts (
    account_id,
    account_number,
    bank_name,
    branch_name,
    swift_code
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, created_at, updated_at, deleted_at, account_id, account_number, bank_name, branch_name, swift_code
`

type CreateBankAccountParams struct {
	AccountID     int32
	AccountNumber string
	BankName      string
	BranchName    pgtype.Text
	SwiftCode     pgtype.Text
}

func (q *Queries) CreateBankAccount(ctx context.Context, arg CreateBankAccountParams) (BankAccount, error) {
	row := q.db.QueryRow(ctx, createBankAccount,
		arg.AccountID,
		arg.AccountNumber,
		arg.BankName,
		arg.BranchName,
		arg.SwiftCode,
	)
	var i BankAccount
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AccountID,
		&i.AccountNumber,
		&i.BankName,
		&i.BranchName,
		&i.SwiftCode,
	)
	return i, err
}

const deleteBankAccount = `-- name: DeleteBankAccount :one
UPDATE bank_accounts
SET
    deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, account_id, account_number, bank_name, branch_name, swift_code
`

func (q *Queries) DeleteBankAccount(ctx context.Context, id int32) (BankAccount, error) {
	row := q.db.QueryRow(ctx, deleteBankAccount, id)
	var i BankAccount
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AccountID,
		&i.AccountNumber,
		&i.BankName,
		&i.BranchName,
		&i.SwiftCode,
	)
	return i, err
}

const getBankAccountByAccountID = `-- name: GetBankAccountByAccountID :one
SELECT id, created_at, updated_at, deleted_at, account_id, account_number, bank_name, branch_name, swift_code FROM bank_accounts
WHERE account_id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetBankAccountByAccountID(ctx context.Context, accountID int32) (BankAccount, error) {
	row := q.db.QueryRow(ctx, getBankAccountByAccountID, accountID)
	var i BankAccount
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AccountID,
		&i.AccountNumber,
		&i.BankName,
		&i.BranchName,
		&i.SwiftCode,
	)
	return i, err
}

const getBankAccountByID = `-- name: GetBankAccountByID :one
SELECT id, created_at, updated_at, deleted_at, account_id, account_number, bank_name, branch_name, swift_code FROM bank_accounts
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetBankAccountByID(ctx context.Context, id int32) (BankAccount, error) {
	row := q.db.QueryRow(ctx, getBankAccountByID, id)
	var i BankAccount
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AccountID,
		&i.AccountNumber,
		&i.BankName,
		&i.BranchName,
		&i.SwiftCode,
	)
	return i, err
}

const updateBankAccount = `-- name: UpdateBankAccount :one
UPDATE bank_accounts
SET
    account_number = CASE WHEN $1::text IS NULL THEN account_number ELSE $1 END,
    bank_name = CASE WHEN $2::text IS NULL THEN bank_name ELSE $2 END,
    branch_name = CASE WHEN $3::text IS NULL THEN branch_name ELSE $3 END,
    swift_code = CASE WHEN $4::text IS NULL THEN swift_code ELSE $4 END,
    updated_at = NOW()
WHERE id = $5 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, account_id, account_number, bank_name, branch_name, swift_code
`

type UpdateBankAccountParams struct {
	AccountNumber pgtype.Text
	BankName      pgtype.Text
	BranchName    pgtype.Text
	SwiftCode     pgtype.Text
	ID            int32
}

func (q *Queries) UpdateBankAccount(ctx context.Context, arg UpdateBankAccountParams) (BankAccount, error) {
	row := q.db.QueryRow(ctx, updateBankAccount,
		arg.AccountNumber,
		arg.BankName,
		arg.BranchName,
		arg.SwiftCode,
		arg.ID,
	)
	var i BankAccount
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AccountID,
		&i.AccountNumber,
		&i.BankName,
		&i.BranchName,
		&i.SwiftCode,
	)
	return i, err
}
