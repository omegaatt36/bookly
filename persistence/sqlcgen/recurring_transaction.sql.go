// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: recurring_transaction.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createRecurringTransaction = `-- name: CreateRecurringTransaction :one
INSERT INTO recurring_transactions (
    user_id, account_id, name, type, amount, note,
    start_date, end_date, recur_type, status, frequency,
    day_of_week, day_of_month, month_of_year, next_due
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, created_at, updated_at, deleted_at, user_id, account_id, name, type, amount, note, start_date, end_date, recur_type, status, frequency, day_of_week, day_of_month, month_of_year, last_executed, next_due
`

type CreateRecurringTransactionParams struct {
	UserID      int32
	AccountID   int32
	Name        string
	Type        string
	Amount      decimal.Decimal
	Note        pgtype.Text
	StartDate   pgtype.Timestamptz
	EndDate     pgtype.Timestamptz
	RecurType   string
	Status      string
	Frequency   int32
	DayOfWeek   pgtype.Int4
	DayOfMonth  pgtype.Int4
	MonthOfYear pgtype.Int4
	NextDue     pgtype.Timestamptz
}

func (q *Queries) CreateRecurringTransaction(ctx context.Context, arg CreateRecurringTransactionParams) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, createRecurringTransaction,
		arg.UserID,
		arg.AccountID,
		arg.Name,
		arg.Type,
		arg.Amount,
		arg.Note,
		arg.StartDate,
		arg.EndDate,
		arg.RecurType,
		arg.Status,
		arg.Frequency,
		arg.DayOfWeek,
		arg.DayOfMonth,
		arg.MonthOfYear,
		arg.NextDue,
	)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.AccountID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.Note,
		&i.StartDate,
		&i.EndDate,
		&i.RecurType,
		&i.Status,
		&i.Frequency,
		&i.DayOfWeek,
		&i.DayOfMonth,
		&i.MonthOfYear,
		&i.LastExecuted,
		&i.NextDue,
	)
	return i, err
}

const deleteRecurringTransaction = `-- name: DeleteRecurringTransaction :one
UPDATE recurring_transactions
SET
    updated_at = NOW(),
    status = 'cancelled',
    deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, user_id, account_id, name, type, amount, note, start_date, end_date, recur_type, status, frequency, day_of_week, day_of_month, month_of_year, last_executed, next_due
`

func (q *Queries) DeleteRecurringTransaction(ctx context.Context, id int32) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, deleteRecurringTransaction, id)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.AccountID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.Note,
		&i.StartDate,
		&i.EndDate,
		&i.RecurType,
		&i.Status,
		&i.Frequency,
		&i.DayOfWeek,
		&i.DayOfMonth,
		&i.MonthOfYear,
		&i.LastExecuted,
		&i.NextDue,
	)
	return i, err
}

const getActiveRecurringTransactionsDue = `-- name: GetActiveRecurringTransactionsDue :many
SELECT id, created_at, updated_at, deleted_at, user_id, account_id, name, type, amount, note, start_date, end_date, recur_type, status, frequency, day_of_week, day_of_month, month_of_year, last_executed, next_due FROM recurring_transactions
WHERE status = 'active' AND next_due <= $1 AND deleted_at IS NULL
ORDER BY next_due ASC
`

func (q *Queries) GetActiveRecurringTransactionsDue(ctx context.Context, nextDue pgtype.Timestamptz) ([]RecurringTransaction, error) {
	rows, err := q.db.Query(ctx, getActiveRecurringTransactionsDue, nextDue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringTransaction{}
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.AccountID,
			&i.Name,
			&i.Type,
			&i.Amount,
			&i.Note,
			&i.StartDate,
			&i.EndDate,
			&i.RecurType,
			&i.Status,
			&i.Frequency,
			&i.DayOfWeek,
			&i.DayOfMonth,
			&i.MonthOfYear,
			&i.LastExecuted,
			&i.NextDue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecurringTransactionByID = `-- name: GetRecurringTransactionByID :one
SELECT id, created_at, updated_at, deleted_at, user_id, account_id, name, type, amount, note, start_date, end_date, recur_type, status, frequency, day_of_week, day_of_month, month_of_year, last_executed, next_due FROM recurring_transactions
WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetRecurringTransactionByID(ctx context.Context, id int32) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, getRecurringTransactionByID, id)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.AccountID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.Note,
		&i.StartDate,
		&i.EndDate,
		&i.RecurType,
		&i.Status,
		&i.Frequency,
		&i.DayOfWeek,
		&i.DayOfMonth,
		&i.MonthOfYear,
		&i.LastExecuted,
		&i.NextDue,
	)
	return i, err
}

const getRecurringTransactionsByUserID = `-- name: GetRecurringTransactionsByUserID :many
SELECT id, created_at, updated_at, deleted_at, user_id, account_id, name, type, amount, note, start_date, end_date, recur_type, status, frequency, day_of_week, day_of_month, month_of_year, last_executed, next_due FROM recurring_transactions
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY next_due ASC
`

func (q *Queries) GetRecurringTransactionsByUserID(ctx context.Context, userID int32) ([]RecurringTransaction, error) {
	rows, err := q.db.Query(ctx, getRecurringTransactionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringTransaction{}
	for rows.Next() {
		var i RecurringTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.AccountID,
			&i.Name,
			&i.Type,
			&i.Amount,
			&i.Note,
			&i.StartDate,
			&i.EndDate,
			&i.RecurType,
			&i.Status,
			&i.Frequency,
			&i.DayOfWeek,
			&i.DayOfMonth,
			&i.MonthOfYear,
			&i.LastExecuted,
			&i.NextDue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecurringTransaction = `-- name: UpdateRecurringTransaction :one
UPDATE recurring_transactions
SET
    updated_at = NOW(),
    name = CASE WHEN $1::text IS NULL THEN name ELSE $1 END,
    type = CASE WHEN $2::text IS NULL THEN type ELSE $2 END,
    amount = CASE WHEN $3::decimal IS NULL THEN amount ELSE $3 END,
    note = CASE WHEN $4::text IS NULL THEN note ELSE $4 END,
    end_date = CASE WHEN $5::timestamptz IS NULL THEN end_date ELSE $5 END,
    recur_type = CASE WHEN $6::text IS NULL THEN recur_type ELSE $6 END,
    status = CASE WHEN $7::text IS NULL THEN status ELSE $7 END,
    frequency = CASE WHEN $8::int IS NULL THEN frequency ELSE $8 END,
    day_of_week = CASE WHEN $9::int IS NULL THEN day_of_week ELSE $9 END,
    day_of_month = CASE WHEN $10::int IS NULL THEN day_of_month ELSE $10 END,
    month_of_year = CASE WHEN $11::int IS NULL THEN month_of_year ELSE $11 END
WHERE id = $12 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, user_id, account_id, name, type, amount, note, start_date, end_date, recur_type, status, frequency, day_of_week, day_of_month, month_of_year, last_executed, next_due
`

type UpdateRecurringTransactionParams struct {
	Name        pgtype.Text
	Type        pgtype.Text
	Amount      pgtype.Numeric
	Note        pgtype.Text
	EndDate     pgtype.Timestamptz
	RecurType   pgtype.Text
	Status      pgtype.Text
	Frequency   pgtype.Int4
	DayOfWeek   pgtype.Int4
	DayOfMonth  pgtype.Int4
	MonthOfYear pgtype.Int4
	ID          int32
}

func (q *Queries) UpdateRecurringTransaction(ctx context.Context, arg UpdateRecurringTransactionParams) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, updateRecurringTransaction,
		arg.Name,
		arg.Type,
		arg.Amount,
		arg.Note,
		arg.EndDate,
		arg.RecurType,
		arg.Status,
		arg.Frequency,
		arg.DayOfWeek,
		arg.DayOfMonth,
		arg.MonthOfYear,
		arg.ID,
	)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.AccountID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.Note,
		&i.StartDate,
		&i.EndDate,
		&i.RecurType,
		&i.Status,
		&i.Frequency,
		&i.DayOfWeek,
		&i.DayOfMonth,
		&i.MonthOfYear,
		&i.LastExecuted,
		&i.NextDue,
	)
	return i, err
}

const updateRecurringTransactionExecution = `-- name: UpdateRecurringTransactionExecution :one
UPDATE recurring_transactions
SET
    updated_at = NOW(),
    last_executed = $1,
    next_due = $2
WHERE id = $3 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, user_id, account_id, name, type, amount, note, start_date, end_date, recur_type, status, frequency, day_of_week, day_of_month, month_of_year, last_executed, next_due
`

type UpdateRecurringTransactionExecutionParams struct {
	LastExecuted pgtype.Timestamptz
	NextDue      pgtype.Timestamptz
	ID           int32
}

func (q *Queries) UpdateRecurringTransactionExecution(ctx context.Context, arg UpdateRecurringTransactionExecutionParams) (RecurringTransaction, error) {
	row := q.db.QueryRow(ctx, updateRecurringTransactionExecution, arg.LastExecuted, arg.NextDue, arg.ID)
	var i RecurringTransaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.AccountID,
		&i.Name,
		&i.Type,
		&i.Amount,
		&i.Note,
		&i.StartDate,
		&i.EndDate,
		&i.RecurType,
		&i.Status,
		&i.Frequency,
		&i.DayOfWeek,
		&i.DayOfMonth,
		&i.MonthOfYear,
		&i.LastExecuted,
		&i.NextDue,
	)
	return i, err
}
