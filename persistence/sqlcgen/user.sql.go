// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addIdentity = `-- name: AddIdentity :one
INSERT INTO identities (
    user_id,
    provider,
    identifier,
    credential,
    last_used_at
) VALUES (
    $1, $2, $3, $4, NOW()
)
RETURNING id, user_id, provider, identifier, credential, last_used_at
`

type AddIdentityParams struct {
	UserID     int32
	Provider   string
	Identifier string
	Credential string
}

func (q *Queries) AddIdentity(ctx context.Context, arg AddIdentityParams) (Identity, error) {
	row := q.db.QueryRow(ctx, addIdentity,
		arg.UserID,
		arg.Provider,
		arg.Identifier,
		arg.Credential,
	)
	var i Identity
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.Identifier,
		&i.Credential,
		&i.LastUsedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    name,
    nickname
) VALUES (
    $1, $2
)
RETURNING id, created_at, updated_at, deleted_at, disabled, name, nickname
`

type CreateUserParams struct {
	Name     string
	Nickname pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Name, arg.Nickname)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Disabled,
		&i.Name,
		&i.Nickname,
	)
	return i, err
}

const deactivateUserByID = `-- name: DeactivateUserByID :one
UPDATE users
SET
    disabled = true,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, disabled, name, nickname
`

func (q *Queries) DeactivateUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, deactivateUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Disabled,
		&i.Name,
		&i.Nickname,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :one
UPDATE users
SET
    deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, disabled, name, nickname
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, deleteUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Disabled,
		&i.Name,
		&i.Nickname,
	)
	return i, err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, created_at, updated_at, deleted_at, disabled, name, nickname FROM users
WHERE deleted_at IS NULL
ORDER BY id
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Disabled,
			&i.Name,
			&i.Nickname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, created_at, updated_at, deleted_at, disabled, name, nickname FROM users
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Disabled,
		&i.Name,
		&i.Nickname,
	)
	return i, err
}

const getUserByIdentity = `-- name: GetUserByIdentity :one
SELECT
    u.id AS user_id,
    u.created_at AS user_created_at,
    u.updated_at AS user_updated_at,
    u.disabled AS user_disabled,
    u.name AS user_name,
    u.nickname AS user_nickname,
    i.id AS identity_id,
    i.user_id AS identity_user_id,
    i.provider AS identity_provider,
    i.identifier AS identity_identifier,
    i.credential AS identity_credential,
    i.last_used_at AS identity_last_used_at
FROM users u
JOIN identities i ON u.id = i.user_id
WHERE i.provider = $1 AND i.identifier = $2 AND u.deleted_at IS NULL
LIMIT 1
`

type GetUserByIdentityParams struct {
	Provider   string
	Identifier string
}

type GetUserByIdentityRow struct {
	UserID             int32
	UserCreatedAt      pgtype.Timestamptz
	UserUpdatedAt      pgtype.Timestamptz
	UserDisabled       bool
	UserName           string
	UserNickname       pgtype.Text
	IdentityID         int32
	IdentityUserID     int32
	IdentityProvider   string
	IdentityIdentifier string
	IdentityCredential string
	IdentityLastUsedAt pgtype.Timestamptz
}

func (q *Queries) GetUserByIdentity(ctx context.Context, arg GetUserByIdentityParams) (GetUserByIdentityRow, error) {
	row := q.db.QueryRow(ctx, getUserByIdentity, arg.Provider, arg.Identifier)
	var i GetUserByIdentityRow
	err := row.Scan(
		&i.UserID,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
		&i.UserDisabled,
		&i.UserName,
		&i.UserNickname,
		&i.IdentityID,
		&i.IdentityUserID,
		&i.IdentityProvider,
		&i.IdentityIdentifier,
		&i.IdentityCredential,
		&i.IdentityLastUsedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    name = CASE WHEN $1::text IS NULL THEN name ELSE $1 END,
    nickname = CASE WHEN $2::text IS NULL THEN nickname ELSE $2 END,
    disabled = CASE WHEN $3::boolean IS NULL THEN disabled ELSE $3 END,
    updated_at = NOW()
WHERE id = $4 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, disabled, name, nickname
`

type UpdateUserParams struct {
	Name     pgtype.Text
	Nickname pgtype.Text
	Disabled pgtype.Bool
	ID       int32
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Name,
		arg.Nickname,
		arg.Disabled,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Disabled,
		&i.Name,
		&i.Nickname,
	)
	return i, err
}
