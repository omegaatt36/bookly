// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: budget.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createBudget = `-- name: CreateBudget :one
INSERT INTO budgets (
    user_id,
    name,
    category,
    amount,
    period_type,
    start_date,
    end_date,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, created_at, updated_at, deleted_at, user_id, name, category, amount, period_type, start_date, end_date, is_active
`

type CreateBudgetParams struct {
	UserID     int32
	Name       string
	Category   string
	Amount     decimal.Decimal
	PeriodType string
	StartDate  pgtype.Timestamptz
	EndDate    pgtype.Timestamptz
	IsActive   bool
}

func (q *Queries) CreateBudget(ctx context.Context, arg CreateBudgetParams) (Budget, error) {
	row := q.db.QueryRow(ctx, createBudget,
		arg.UserID,
		arg.Name,
		arg.Category,
		arg.Amount,
		arg.PeriodType,
		arg.StartDate,
		arg.EndDate,
		arg.IsActive,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Name,
		&i.Category,
		&i.Amount,
		&i.PeriodType,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
	)
	return i, err
}

const deleteBudget = `-- name: DeleteBudget :exec
UPDATE budgets
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteBudget(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBudget, id)
	return err
}

const getActiveBudgetByUserIDCategoryAndPeriod = `-- name: GetActiveBudgetByUserIDCategoryAndPeriod :one
SELECT id, created_at, updated_at, deleted_at, user_id, name, category, amount, period_type, start_date, end_date, is_active FROM budgets
WHERE user_id = $1 
AND category = $2 
AND period_type = $3
AND is_active = true
AND deleted_at IS NULL
AND start_date <= $4
AND (end_date IS NULL OR end_date >= $4)
ORDER BY created_at DESC
LIMIT 1
`

type GetActiveBudgetByUserIDCategoryAndPeriodParams struct {
	UserID     int32
	Category   string
	PeriodType string
	StartDate  pgtype.Timestamptz
}

func (q *Queries) GetActiveBudgetByUserIDCategoryAndPeriod(ctx context.Context, arg GetActiveBudgetByUserIDCategoryAndPeriodParams) (Budget, error) {
	row := q.db.QueryRow(ctx, getActiveBudgetByUserIDCategoryAndPeriod,
		arg.UserID,
		arg.Category,
		arg.PeriodType,
		arg.StartDate,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Name,
		&i.Category,
		&i.Amount,
		&i.PeriodType,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
	)
	return i, err
}

const getActiveBudgetsByUserID = `-- name: GetActiveBudgetsByUserID :many
SELECT id, created_at, updated_at, deleted_at, user_id, name, category, amount, period_type, start_date, end_date, is_active FROM budgets
WHERE user_id = $1 AND deleted_at IS NULL AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) GetActiveBudgetsByUserID(ctx context.Context, userID int32) ([]Budget, error) {
	rows, err := q.db.Query(ctx, getActiveBudgetsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Name,
			&i.Category,
			&i.Amount,
			&i.PeriodType,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetByID = `-- name: GetBudgetByID :one
SELECT id, created_at, updated_at, deleted_at, user_id, name, category, amount, period_type, start_date, end_date, is_active FROM budgets
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetBudgetByID(ctx context.Context, id int32) (Budget, error) {
	row := q.db.QueryRow(ctx, getBudgetByID, id)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Name,
		&i.Category,
		&i.Amount,
		&i.PeriodType,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
	)
	return i, err
}

const getBudgetsByUserID = `-- name: GetBudgetsByUserID :many
SELECT id, created_at, updated_at, deleted_at, user_id, name, category, amount, period_type, start_date, end_date, is_active FROM budgets
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetBudgetsByUserID(ctx context.Context, userID int32) ([]Budget, error) {
	rows, err := q.db.Query(ctx, getBudgetsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Name,
			&i.Category,
			&i.Amount,
			&i.PeriodType,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetsByUserIDAndCategory = `-- name: GetBudgetsByUserIDAndCategory :many
SELECT id, created_at, updated_at, deleted_at, user_id, name, category, amount, period_type, start_date, end_date, is_active FROM budgets
WHERE user_id = $1 AND category = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
`

type GetBudgetsByUserIDAndCategoryParams struct {
	UserID   int32
	Category string
}

func (q *Queries) GetBudgetsByUserIDAndCategory(ctx context.Context, arg GetBudgetsByUserIDAndCategoryParams) ([]Budget, error) {
	rows, err := q.db.Query(ctx, getBudgetsByUserIDAndCategory, arg.UserID, arg.Category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Name,
			&i.Category,
			&i.Amount,
			&i.PeriodType,
			&i.StartDate,
			&i.EndDate,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLedgersByCategoryAndDateRange = `-- name: GetLedgersByCategoryAndDateRange :many
SELECT id, created_at, updated_at, deleted_at, account_id, date, type, amount, note, category, is_adjustment, adjusted_from, is_voided, voided_at FROM ledgers
WHERE account_id IN (
    SELECT id FROM accounts WHERE user_id = $1 AND deleted_at IS NULL
)
AND category = $2
AND date >= $3
AND date <= $4
AND deleted_at IS NULL
AND is_voided = false
ORDER BY date DESC
`

type GetLedgersByCategoryAndDateRangeParams struct {
	UserID   int32
	Category pgtype.Text
	Date     pgtype.Timestamptz
	Date_2   pgtype.Timestamptz
}

func (q *Queries) GetLedgersByCategoryAndDateRange(ctx context.Context, arg GetLedgersByCategoryAndDateRangeParams) ([]Ledger, error) {
	rows, err := q.db.Query(ctx, getLedgersByCategoryAndDateRange,
		arg.UserID,
		arg.Category,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ledger{}
	for rows.Next() {
		var i Ledger
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AccountID,
			&i.Date,
			&i.Type,
			&i.Amount,
			&i.Note,
			&i.Category,
			&i.IsAdjustment,
			&i.AdjustedFrom,
			&i.IsVoided,
			&i.VoidedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLedgersSumByCategoryAndDateRange = `-- name: GetLedgersSumByCategoryAndDateRange :one
SELECT COALESCE(SUM(
    CASE 
        WHEN type = 'expense' THEN amount
        WHEN type = 'income' THEN -amount
        ELSE 0
    END
), 0)::DECIMAL(20, 2) as total_expense
FROM ledgers
WHERE account_id IN (
    SELECT id FROM accounts WHERE user_id = $1 AND deleted_at IS NULL
)
AND category = $2
AND date >= $3
AND date <= $4
AND deleted_at IS NULL
AND is_voided = false
`

type GetLedgersSumByCategoryAndDateRangeParams struct {
	UserID   int32
	Category pgtype.Text
	Date     pgtype.Timestamptz
	Date_2   pgtype.Timestamptz
}

func (q *Queries) GetLedgersSumByCategoryAndDateRange(ctx context.Context, arg GetLedgersSumByCategoryAndDateRangeParams) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, getLedgersSumByCategoryAndDateRange,
		arg.UserID,
		arg.Category,
		arg.Date,
		arg.Date_2,
	)
	var total_expense decimal.Decimal
	err := row.Scan(&total_expense)
	return total_expense, err
}

const updateBudget = `-- name: UpdateBudget :one
UPDATE budgets
SET
    name = COALESCE($2, name),
    category = COALESCE($3, category),
    amount = COALESCE($4, amount),
    period_type = COALESCE($5, period_type),
    start_date = COALESCE($6, start_date),
    end_date = COALESCE($7, end_date),
    is_active = COALESCE($8, is_active),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, user_id, name, category, amount, period_type, start_date, end_date, is_active
`

type UpdateBudgetParams struct {
	ID         int32
	Name       string
	Category   string
	Amount     decimal.Decimal
	PeriodType string
	StartDate  pgtype.Timestamptz
	EndDate    pgtype.Timestamptz
	IsActive   bool
}

func (q *Queries) UpdateBudget(ctx context.Context, arg UpdateBudgetParams) (Budget, error) {
	row := q.db.QueryRow(ctx, updateBudget,
		arg.ID,
		arg.Name,
		arg.Category,
		arg.Amount,
		arg.PeriodType,
		arg.StartDate,
		arg.EndDate,
		arg.IsActive,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Name,
		&i.Category,
		&i.Amount,
		&i.PeriodType,
		&i.StartDate,
		&i.EndDate,
		&i.IsActive,
	)
	return i, err
}
